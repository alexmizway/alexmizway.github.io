# 
#### The artifact I will be discussing today is a Binary Search Tree made in C++. This project was made to show the ability to handle and demonstrate the capabilities of data structures within a programming language. I believe that the project was made in early 2021 as I do not have any evidence stating otherwise. I selected this artifact to show that despite C++ being my weak point, I planned on using it to show my growth with the C++ language. The main point of improvements I was making with this artifact was implementing smart pointers and a destructor into the code, but I have decided to switch course and start working on implementing different search algorithms to test their efficiency compared to the binary search tree and those search algorithms are breadth first search and in order depth first search. 
#### The two course outcomes that this artifact demonstrates in my opinion is “Design and evaluate computing solutions that solve a given problem using algorithmic principles and computer science practices and standards appropriate to its solution, while managing the trade-offs involved in design choices”. The reason I believe this outcome is what my data structure artifact reached for is because I have demonstrated the ability to program solution to solve logic problems as I have implemented counters for when inserting, searching, and deleting is called as well as still implementing smart pointers through the usage of shared_ptr.
#### The first challenge I faced during the process was learning what kind of smart pointer I should use in the code. I originally tried unique_ptr but found that to be insufficient for the constant calls for the root node so I have it using a shared_ptr instead. I was trying to find a way to convert the smart pointer into a standard node for the rest of the functions within the artifact when I realized that I needed to program the smart pointer into the methods themselves too. My next challenge came from trying to find the best search algorithms to compare to the binary search tree. I first tried to implement ternary search until a peer informed me that meant having to either convert the whole tree or create a whole new tree with the three paths. 
